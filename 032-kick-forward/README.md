# 后续传递风格

## 约束

作为[流水线风格](../023-pipeline/README.md)的变体，该风格增加了一下约束条件：

- 每个函数都有一个额外的参数（通常最后一个），指向另一函数
- 函数末尾，传入的函数参数被调用
- 输入函数参数执行后的结果，作为当前函数的输出
- **流水线中下一个被调用的函数会作为当前函数的参数给出**

## 注解

后续传递风格，在函数尾部调用传入的函数参数，并将当前函数的计算结果以参数形式传递给函数参数执行。这使得函数**无需返回至其调用者，而得以继续执行其他协作函数**。

示例程序中，主程序调用函数`read_file`，指明要读取的文件名及`read_file`完成后调用的函数 —— `filter_chars`

``` python
import sys

def read_file(path_to_file, func):
    with open(path_to_file) as f:
        data = f.read()
    func(data, normalize)

def filter_chars(text, func):
    # ...

def normalize(text, func):
    # ...

#
# 主函数
#
read_file(sys.argv[1], filter_chars)
```

流水线风格在主程序中包含一条函数链，定义了“工厂”流水线的所有步骤；后续则是一个表示“**程序剩余部分**”的函数，该风格起源于`goto`语句，能够为**函数的非本地返回**提供一般化机制，可作为`goto`语句和异常等语言结构的替代方案。如 JavaScript 和其他不支持线程的语言中的**回调函数**，但过多的嵌套会导致可读性差的回调地狱。

## 应用

后续传递风格又可被称为**多米诺骨牌风格**，可满足不同的编程目的：

- 编译器优化，编译源代码为该风格的中间转译结果，从而**优化尾部调用**
- 处理程序成功流程和异常流程，如 NodeJS 中的`error first`回调
- 解决单线程语言的 I/O 阻塞问题。如网络或磁盘等待，原则上会阻塞线程。但当定义下一步无论成功或失败相应的操作后，应用程序可以返回当前函数的调用，继续执行下一条指令。
