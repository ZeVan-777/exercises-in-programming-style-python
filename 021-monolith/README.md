# 单片风格

## 约束

- 没有命名的抽象对象
- 没有或几乎不使用库

## 注解

在单片风格中，一长串的代码，从头到尾既没有提出任何新的抽象概念，也没有使用许多库里已有的抽象概念。从设计角度，没有思考如何**细分问题**，或如何充分利用**已有代码**。整个问题是一个*单一的概念单元*，编程任务定义了该单元的**数据和控制流**。

示例程序中，程序的大循环，逐行迭代输入文件；大循环的内部的次级嵌套循环，迭代输入文件中每一行的每一个字母。

```python
for line in open(sys.argv[1]):
    start_char = None
    i = 0
    for c in line:
       # 寻找单词后处理。。。
    i += 1
```

这个嵌套循环需要解决的问题是检测单词的开始位置和结束位置，以截取单词；随后将非停止词的计数加1。在整个大循环过程中处理单词的过程中，每个单词的频数信息依次更新在`word_freqs`列表。每一次新增词频信息频数为1，更新在队尾；而频数加1后的单词需要在列表中**（冒泡）前移**。

```python
if not found:
    word_freqs.append([word, 1])
elif len(word_freqs) > 1:
    # 降序排列，加1后从后往前冒牌
    for n in reversed(range(found_at)):
        if word_freqs[found_at][1] > word_freqs[n][1]:
            # 前后交换
            word_freqs[n], word_freqs[found_at] = word_freqs[found_at], word_freqs[n]
            wf_index = n
        else: # 没有比前面的数更大，终止冒泡
            break
```

## 发展历史

在计算机编程的初级阶段，局限于**底层编程语言**和**规模相对较小的程序环境**，一般采取这样的编程风格。类似`goto`这样的概念提升了控制流的表达能力，也促成了“*面条式代码*（spaghetti code）”的出现。

从维护角度上来说，针对程序正在解决的问题，一长串代码无法给予读者恰当的、更高级别的抽象。在某些情况下，冗长的代码是必要的，如**性能所限**或**任务不容易被分解**；但很多情况下，它们的出现只是因为程序员没有花时间认真思考手头上的计算任务。

在系统层面上，单片风格表现为利用*独立、大型的组件实现应用需要完成的每一项工作*。这与将整个系统分解成模块化的**子系统**，分别进行特定功能的运作方式是背道而驰的。
