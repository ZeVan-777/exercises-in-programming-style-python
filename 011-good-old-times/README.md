# 往日的“美好”

## 约束

约束通常源于外部，如硬件的内存有限、汇编代码不支持标识符……这种20世纪50年代早期编程的特定约束，其实并未绝迹，如今仍然在硬件的直接交互以及内存优化的场景下存在。

1. **内存容量有限**，通常量级小于需要处理、生成的数据量 => 程序员在可用内存循环使用受限的变量，使计算任务变得复杂。
2. **无标识符**，即没有变量名或带标签的内存地址 => 代码文字不自然通顺，只能通过注释和文档补足

## 注解

内存约束使待处理数据的大小不可忽略，对于《傲慢与偏见》这样远超限制的书，需要将文件**分成若干个小块**来读取处理，且**将超出内存限制的数据存入辅助存储器** —— 一个文件中。

内存能直接被 CPU 无需顺序扫描、快速寻址地访问，而辅存相对于内存则需要通过IO总线被间接访问，速度慢得多。因此，“**什么将存入内存**”、“**什么将存入辅存**”以及“**何时将内容存入辅存**”的考量与性能优化息息相关。

本例中，待处理数据以行为单位划分，且每行小于 80 字节数据，加上 556 字节大小的需滤除停止词数据，对内存空间大小的占用仍小于 1024 字节的限制，因此才能采用数据按行处理、一次读取所有停止词的策略以简化程序 —— 内存的约束影响算法的选用。

缺少语义化标识符的约束，则表现在了程序的可读性差。没有变量，数据内存只能通过数字下表访问，导致**问题域的原生概念**，如单词、频数、排序等，只能通过内存下标寻址的方式间接表述。虽然可以注释每个内存单元中数据的意义，但阅读代码却时常需要回忆内存单元意义。

## 发展历程

图灵机 —— 第一个可实现的计算模型，其编程模型包含：**带有符号的纸带、可以左右移动的纸带输入/输出设备，以及纸带上符号的可复写性**；加上其后受图灵思想启发的冯·诺依曼设计出了第一台存储程序计算机；共同引领了20世纪50年代编程语言的发展，并**赋予编程以重用且变化内存状态的概念**。

正如摩尔定律断定的那样，“受限的内存”基本只是过去模糊的记忆，现代编程语言强调**透明的内存管理**。但程序处理中不断增长的数据规模，让程序员很容易失去对程序内存消耗的控制，从而导致运行时性能下降。因此，了解不同程序充风格的内存使用策略及其后果，仍有必要。

随着**大数据**的出现，内存再一次出现了**相对意义上的有限**——远小于需要处理的数据量。此时，开发者也许需要回首往昔，寻找一种更多在各种情况下都可适应内存大小的表达方法 —— 数据在主存和辅存之间轮转。

另一方面，标识符的缺失，导致只能使用**注释、文档这种间接表述**。消除间接表述带来的思维负担，正是编程语言进化的一个主要目的。程序语言要能反映出**问题域的原生概念**，而不是低级的计算机概念，并且还要依靠文档来对应到问题。
